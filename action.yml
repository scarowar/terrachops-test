name: "terraform-branch-deploy"

description: "A reusable composite action for branch-based, IssueOps-driven Terraform deployments."
author: "Scarowar"

branding:
  icon: "terminal"
  color: "purple"

inputs:
  # --- Authentication & Permissions ---
  github-token:
    description: "The GitHub token for authentication (e.g., ${{ secrets.GITHUB_TOKEN }}). Requires 'contents: write', 'pull-requests: write', 'actions: read', and 'deployments: write' permissions."
    required: true

  # --- Terraform Tooling Configuration ---
  terraform-version:
    description: "The version of Terraform CLI to install. Instead of full version string you can also specify constraint string starting with '<' (for example '<1.13.0') to install the latest version satisfying the constraint. A value of 'latest' will install the latest version of Terraform CLI. Defaults to 'latest'."
    required: false
    default: "latest"

  # --- Terraform Project Path Configuration ---
  working-directory:
    description: "The default path to the Terraform code, relative to the repository root. This can be overridden per environment in .tf-branch-deploy.yml."
    required: false
    default: "."

  # --- IssueOps Command Triggers ---
  noop-trigger:
    description: "The comment trigger (e.g., '.plan') that initiates a Terraform plan without applying."
    required: false
    default: ".plan"
  trigger:
    description: "The comment trigger (e.g., '.apply') that initiates a Terraform apply."
    required: false
    default: ".apply"

  # --- Deployment Logic & Rollback Settings ---
  stable_branch:
    description: "The name of the stable branch (e.g., 'main' or 'develop') used for rollback deployments."
    required: false
    default: "main"

runs:
  using: "composite"
  steps:
    - name: "üì• Initial Repository Checkout (for action's internal scripts)"
      uses: actions/checkout@v4
      with:
        ref: ${{ github.sha }}
        fetch-depth: 1

    - name: "üõ†Ô∏è Install Common System Utilities (Linux/macOS)"
      shell: bash
      run: |
        set -euo pipefail
        if [[ "${{ runner.os }}" == "Linux" ]]; then
          if command -v apt-get >/dev/null 2>&1; then
            echo "üì¶ Updating apt-get and installing common dependencies..."
            sudo apt-get update -y
            for cmd in git curl unzip ca-certificates software-properties-common xz-utils; do
              if ! command -v "$cmd" >/dev/null 2>&1; then
                echo "Installing $cmd..."
                sudo apt-get install -y "$cmd"
              else
                echo "‚úÖ $cmd is already installed."
              fi
            done
          elif command -v yum >/dev/null 2>&1; then
            echo "üì¶ Updating yum and installing common dependencies..."
            sudo yum makecache
            for cmd in git curl unzip ca-certificates xz-utils; do
              if ! command -v "$cmd" >/dev/null 2>&1; then
                echo "Installing $cmd..."
                sudo yum install -y "$cmd"
              else
                echo "‚úÖ $cmd is already installed."
              fi
            done
          else
            echo "::warning::Neither apt-get nor yum found on Linux. Please ensure git, curl, unzip, ca-certificates, software-properties-common (for apt), and xz-utils are available on your self-hosted runner image."
          fi
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          if command -v brew >/dev/null 2>&1; then
            echo "üç∫ Updating Homebrew and installing common dependencies..."
            brew update
            for cmd in git curl unzip; do
              if ! command -v "$cmd" >/dev/null 2>&1; then
                echo "Installing $cmd..."
                brew install "$cmd"
              else
                echo "‚úÖ $cmd is already installed."
              fi
            done
          else
            echo "::warning::Homebrew not found on macOS. Please ensure git, curl, and unzip are available on your self-hosted runner image."
          fi
        elif [[ "${{ runner.os }}" == "Windows" ]]; then
            echo "::warning::Windows runners detected. Please ensure all required utilities (git, curl, unzip) are pre-installed or installable via Chocolatey/Winget if not already present on your self-hosted runner image."
        else
            echo "::warning::Unsupported OS: ${{ runner.os }}. Please ensure all required utilities are available on your self-hosted runner image."
        fi

    - name: "üåê Setup Node.js Environment"
      uses: actions/setup-node@v4
      with:
        node-version: "20"

    - name: "üêç Setup Python Environment and Dependencies"
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"
        cache: "pip"
        cache-dependency-path: scripts/requirements.txt

    - name: "üìú Install yq (YAML Processor)"
      shell: bash
      run: |
        set -euo pipefail
        if command -v yq >/dev/null 2>&1; then
          echo "‚úÖ yq is already installed. Version:"
          yq --version
        else
          echo "‚¨áÔ∏è Installing yq..."
          YQ_VERSION="v4.45.4"
          OS_TYPE=$(uname -s)
          ARCH=$(uname -m)

          case "$OS_TYPE" in
            Linux)
              case "$ARCH" in
                x86_64) ARCH_TAG=amd64 ;;
                aarch64) ARCH_TAG=arm64 ;;
                *) echo "::error::Unsupported Linux architecture for yq: $ARCH" && exit 1 ;;
              esac
              YQ_URL="https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_${ARCH_TAG}"
              DEST_PATH="/usr/local/bin/yq"
              ;;
            Darwin)
              case "$ARCH" in
                x86_64) ARCH_TAG=amd64 ;;
                arm64) ARCH_TAG=arm64 ;;
                *) echo "::error::Unsupported macOS architecture for yq: $ARCH" && exit 1 ;;
              esac
              YQ_URL="https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_darwin_${ARCH_TAG}"
              DEST_PATH="/usr/local/bin/yq"
              ;;
            MINGW*|CYGWIN*|MSYS*)
              ARCH_TAG=amd64
              YQ_URL="https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_windows_${ARCH_TAG}.exe"
              DEST_PATH="/c/ProgramData/chocolatey/lib/yq/tools/yq.exe"
              mkdir -p "$(dirname "$DEST_PATH")"
              ;;
            *)
              echo "::error::Unsupported OS for yq installation: $OS_TYPE"
              exit 1
              ;;
          esac

          echo "Attempting to download yq from: $YQ_URL to $DEST_PATH"
          if ! curl -sSL "$YQ_URL" -o "$DEST_PATH"; then
            echo "::error::Failed to download yq from $YQ_URL. Check network connectivity or URL."
            exit 1
          fi
          chmod +x "$DEST_PATH"
          echo "$DEST_PATH" >> $GITHUB_PATH
          yq --version
          echo "‚úÖ yq installed successfully."
        fi

    - name: "üö¶ Pre-flight Checks"
      id: preflight
      run: |
        set -euo pipefail
        CONFIG_FILE="${GITHUB_WORKSPACE}/.tf-branch-deploy.yml"
        if [ -f "$CONFIG_FILE" ]; then
          ENVS=$(yq e '.environments | keys | .[]' "$CONFIG_FILE" | tr '\n' ',' | sed 's/,$//')
          echo "‚úÖ Discovered environments: ${ENVS}"
          echo "available_envs=${ENVS}" >> "$GITHUB_OUTPUT"
        else
          echo "available_envs=" >> "$GITHUB_OUTPUT"
          echo "::notice::No .tf-branch-deploy.yml found at '${CONFIG_FILE}'. Proceeding with default 'production' environment only."
        fi
      shell: bash

    - name: "üõ∏ IssueOps Command Dispatcher"
      id: branch-deploy
      uses: github/branch-deploy@e837cad62fcc6f5f45997baafd69c57ea9b0641d
      with:
        github_token: ${{ inputs.github-token }}
        noop_trigger: ${{ inputs.noop-trigger }}
        trigger: ${{ inputs.trigger }}
        environment_targets: "${{ steps.preflight.outputs.available_envs || 'production' }}"
        stable_branch: ${{ inputs.stable_branch }}

    - name: "üì• Checkout Target Code for Terraform Execution"
      uses: actions/checkout@v4
      with:
        ref: ${{ steps.branch-deploy.outputs.sha }}
        fetch-depth: 0
        path: repo_checkout

    - name: "üîë Ensure prepare_tf_branch_deploy.py is executable"
      if: steps.branch-deploy.outputs.continue == 'true'
      run: |
        set -euo pipefail
        chmod +x ${GITHUB_ACTION_PATH}/scripts/prepare_tf_branch_deploy.py
      shell: bash

    - name: "üìù Prepare terraform-branch-deploy Commands"
      if: steps.branch-deploy.outputs.continue == 'true'
      id: prepare_cmds
      run: |
        set -euo pipefail
        VENV_PATH="${GITHUB_WORKSPACE}/.venv-terraform-branch-deploy"

        echo "üêç Setting up Python virtual environment at: $VENV_PATH"
        python3 -m venv "$VENV_PATH"
        source "$VENV_PATH/bin/activate"
        echo "‚úÖ Python virtual environment activated."

        echo "‚¨áÔ∏è Upgrading pip..."
        pip install --upgrade pip
        echo "‚úÖ pip upgraded."

        echo "Installing Python dependencies from requirements.txt..."
        pip install -r "${GITHUB_ACTION_PATH}/scripts/requirements.txt"
        echo "‚úÖ Python dependencies installed."

        python "${GITHUB_ACTION_PATH}/scripts/prepare_tf_branch_deploy.py" \
          "${{ inputs.working-directory }}" \
          "${{ steps.branch-deploy.outputs.environment }}" \
          "${{ steps.branch-deploy.outputs.params }}"
      shell: bash
      working-directory: repo_checkout

    - name: "‚öôÔ∏è Setup Terraform CLI"
      if: steps.branch-deploy.outputs.continue == 'true'
      uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd
      with:
        terraform_version: ${{ inputs.terraform-version }}

    - name: "üå± Terraform Init"
      if: steps.branch-deploy.outputs.continue == 'true'
      id: init
      run: |
        set -euo pipefail
        echo "Initializing Terraform backend and modules..."
        terraform init ${{ steps.prepare_cmds.outputs.init_args }}
        echo "‚úÖ Terraform Init completed."
      shell: bash
      working-directory: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}

    - name: "üßπ Terraform Format Check"
      if: steps.branch-deploy.outputs.continue == 'true'
      id: fmt
      run: |
        set -euo pipefail
        echo "Checking Terraform format..."
        terraform fmt -check
        echo "‚úÖ Terraform format check passed."
      shell: bash
      working-directory: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}

    - name: "‚úÖ Terraform Validate"
      if: steps.branch-deploy.outputs.continue == 'true'
      id: validate
      run: |
        set -euo pipefail
        echo "Validating Terraform configuration..."
        terraform validate
        echo "‚úÖ Terraform validation passed."
      shell: bash
      working-directory: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}

    # Rollback Plan and Apply:
    - name: "üö® Rollback Plan and Apply"
      if: steps.branch-deploy.outputs.ref == inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false'
      id: rollback
      run: |
        set -euo pipefail
        echo "üö® Performing immediate plan and apply for stable branch rollback."
        PLAN_OUTPUT_FILE="rollback_plan.txt"
        APPLY_OUTPUT_FILE="rollback_apply.txt"
        PLAN_BINARY_FILE="rollback.plan"

        echo "Running terraform plan for rollback..."
        terraform plan ${{ steps.prepare_cmds.outputs.plan_args }} -no-color -out="$PLAN_BINARY_FILE" | tee "$PLAN_OUTPUT_FILE"
        PLAN_EXIT_CODE=${PIPESTATUS[0]}

        echo "Running terraform apply for rollback..."
        terraform apply -auto-approve ${{ steps.prepare_cmds.outputs.apply_args }} "$PLAN_BINARY_FILE" -no-color | tee "$APPLY_OUTPUT_FILE"
        APPLY_EXIT_CODE=${PIPESTATUS[0]}

        MAX_COMMENT_SIZE=64000
        ARTIFACT_NEEDED=false
        FULL_APPLY_PATH="${GITHUB_WORKSPACE}/repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/${APPLY_OUTPUT_FILE}"

        if [ -f "$FULL_APPLY_PATH" ] && [ $(wc -c < "$FULL_APPLY_PATH") -gt $MAX_COMMENT_SIZE ]; then
          ARTIFACT_NEEDED=true
          echo "artifact_needed=true" >> $GITHUB_OUTPUT
        else
          echo "artifact_needed=false" >> $GITHUB_OUTPUT
        fi

        echo "apply_exit_code=$APPLY_EXIT_CODE" >> "$GITHUB_OUTPUT"
        echo "plan_exit_code=$PLAN_EXIT_CODE" >> "$GITHUB_OUTPUT"

        if [ "$APPLY_EXIT_CODE" -eq 0 ]; then
          echo "‚úÖ Terraform rollback apply completed successfully."
        elif [ "$APPLY_EXIT_CODE" -eq 1 ]; then
          echo "::error::Terraform rollback apply failed with a critical error."
        else
          echo "::warning::Terraform rollback apply completed with non-zero exit code: $APPLY_EXIT_CODE."
        fi
        exit "$APPLY_EXIT_CODE"
      shell: bash
      working-directory: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}

    - name: "üì§ Upload Rollback Apply Output Artifact"
      if: steps.rollback.outputs.artifact_needed == 'true'
      id: upload_rollback_artifact
      uses: actions/upload-artifact@v3
      with:
        name: rollback-apply-output-${{ steps.branch-deploy.outputs.sha }}
        path: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/rollback_apply.txt
        compression-level: 0

    - name: "üîó Get Rollback Artifact URL"
      if: steps.rollback.outputs.artifact_needed == 'true'
      id: get_rollback_artifact_url
      uses: actions/github-script@v7
      with:
        script: |
          const runId = context.runId;
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const sha = "${{ steps.branch-deploy.outputs.sha }}";
          const artifactName = `rollback-apply-output-${sha}`;

          try {
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: owner,
              repo: repo,
              run_id: runId
            });

            const artifact = artifacts.data.artifacts.find(a => a.name === artifactName);
            if (artifact) {
              core.setOutput('artifact_url', artifact.archive_download_url);
              core.debug(`Found artifact URL: ${artifact.archive_download_url}`);
            } else {
              core.setOutput('artifact_url', '');
              core.warning(`Artifact '${artifactName}' not found for run ${runId}. This might indicate a problem with artifact upload.`);
            }
          } catch (error) {
            core.setFailed(`Failed to get artifact URL: ${error.message}`);
          }
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}

    - name: "‚úÇÔ∏è Truncate Rollback Apply Output for PR Comment"
      if: steps.branch-deploy.outputs.ref == inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false'
      id: truncate_rollback
      shell: bash
      run: |
        set -euo pipefail
        MAX_COMMENT_SIZE=64000
        INPUT_FILE="rollback_apply.txt"
        OUTPUT_FILE="rollback_apply.trunc.txt"

        FULL_PATH="${GITHUB_WORKSPACE}/repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/${INPUT_FILE}"
        TRUNC_PATH="${GITHUB_WORKSPACE}/repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/${OUTPUT_FILE}"

        ARTIFACT_NEEDED=${{ steps.rollback.outputs.artifact_needed }}

        if [ -f "$FULL_PATH" ] && [ $(wc -c < "$FULL_PATH") -gt $MAX_COMMENT_SIZE ]; then
          head -c "$MAX_COMMENT_SIZE" "$FULL_PATH" > "$TRUNC_PATH"
          echo -e "\n---\n:warning: Output truncated. See artifact for full details." >> "$TRUNC_PATH"
          echo "truncated_content=$(cat "$TRUNC_PATH")" >> "$GITHUB_OUTPUT"
        else
          cp "$FULL_PATH" "$TRUNC_PATH"
          echo "truncated_content=$(cat "$TRUNC_PATH")" >> "$GITHUB_OUTPUT"
        fi
      working-directory: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}

    - name: "üìù Post Rollback Apply Output to PR"
      if: steps.branch-deploy.outputs.ref == inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false'
      uses: peter-evans/create-or-update-comment@71345be0265236311c031f5c7866368bd1eff043
      with:
        token: ${{ inputs.github-token }}
        repository: ${{ github.repository }}
        issue-number: ${{ github.event.issue.number || github.event.pull_request.number }}
        comment-id: rollback-apply-${{ steps.branch-deploy.outputs.sha }}-${{ steps.branch-deploy.outputs.environment }}
        body: |
          ### üö® Rollback Deployment Status: ${{ (steps.rollback.outputs.apply_exit_code == 0 && '‚úÖ Succeeded') || (steps.rollback.outputs.apply_exit_code == 1 && '‚ùå Failed') || '‚ö†Ô∏è Completed with Changes' }}

          ```terraform
          ${{ steps.truncate_rollback.outputs.truncated_content }}
          ```
          ${{ steps.truncate_rollback.outputs.artifact_needed == 'true' && format('Output truncated. See full log [here]({0}).', steps.get_rollback_artifact_url.outputs.artifact_url) || '' }}
      env:
        APPLY_EXIT_CODE: ${{ steps.rollback.outputs.apply_exit_code }}
        ARTIFACT_URL: ${{ steps.get_rollback_artifact_url.outputs.artifact_url }}
        ARTIFACT_NEEDED: ${{ steps.truncate_rollback.outputs.artifact_needed }}

    # Terraform Plan:
    - name: "üìã Terraform Plan"
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      id: plan
      run: |
        set -euo pipefail
        PLAN_OUTPUT_FILE="tfplan.txt"
        PLAN_BINARY_FILE="tfplan-${{ steps.branch-deploy.outputs.sha }}.binary"

        echo "Running terraform plan..."
        terraform plan ${{ steps.prepare_cmds.outputs.plan_args }} -no-color -out="$PLAN_BINARY_FILE" | tee "$PLAN_OUTPUT_FILE"
        PLAN_EXIT_CODE=$?

        MAX_COMMENT_SIZE=64000
        ARTIFACT_NEEDED=false
        FULL_PLAN_PATH="${GITHUB_WORKSPACE}/repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/${PLAN_OUTPUT_FILE}"

        if [ -f "$FULL_PLAN_PATH" ] && [ $(wc -c < "$FULL_PLAN_PATH") -gt $MAX_COMMENT_SIZE ]; then
          ARTIFACT_NEEDED=true
          echo "artifact_needed=true" >> "$GITHUB_OUTPUT"
        else
          echo "artifact_needed=false" >> "$GITHUB_OUTPUT"
        fi

        echo "plan_exit_code=$PLAN_EXIT_CODE" >> "$GITHUB_OUTPUT"

        if [ "$PLAN_EXIT_CODE" -eq 1 ]; then
          echo "::error::Terraform plan failed with a critical error."
        elif [ "$PLAN_EXIT_CODE" -eq 2 ]; then
          echo "::notice::Terraform plan indicates infrastructure changes are pending."
        else
          echo "::notice::Terraform plan indicates no changes are required."
        fi
        exit "$PLAN_EXIT_CODE"
      shell: bash
      working-directory: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}

    - name: "üì§ Upload Plan Output Artifact"
      if: steps.plan.outputs.artifact_needed == 'true'
      id: upload_plan_artifact
      uses: actions/upload-artifact@v3
      with:
        name: terraform-plan-output-${{ steps.branch-deploy.outputs.sha }}
        path: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/tfplan.txt
        compression-level: 0

    - name: "üîó Get Plan Artifact URL"
      if: steps.plan.outputs.artifact_needed == 'true'
      id: get_plan_artifact_url
      uses: actions/github-script@v7
      with:
        script: |
          const runId = context.runId;
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const sha = "${{ steps.branch-deploy.outputs.sha }}";
          const artifactName = `terraform-plan-output-${sha}`;

          try {
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: owner,
              repo: repo,
              run_id: runId
            });

            const artifact = artifacts.data.artifacts.find(a => a.name === artifactName);
            if (artifact) {
              core.setOutput('artifact_url', artifact.archive_download_url);
              core.debug(`Found artifact URL: ${artifact.archive_download_url}`);
            } else {
              core.setOutput('artifact_url', '');
              core.warning(`Artifact '${artifactName}' not found for run ${runId}. This might indicate a problem with artifact upload.`);
            }
          } catch (error) {
            core.setFailed(`Failed to get artifact URL: ${error.message}`);
          }
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}

    - name: "‚úÇÔ∏è Truncate Plan Output for PR Comment"
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      id: truncate_plan
      shell: bash
      run: |
        set -euo pipefail
        MAX_COMMENT_SIZE=64000
        INPUT_FILE="tfplan.txt"
        OUTPUT_FILE="tfplan.trunc.txt"

        FULL_PATH="${GITHUB_WORKSPACE}/repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/${INPUT_FILE}"
        TRUNC_PATH="${GITHUB_WORKSPACE}/repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/${OUTPUT_FILE}"

        ARTIFACT_NEEDED=${{ steps.plan.outputs.artifact_needed }}

        if [ -f "$FULL_PATH" ] && [ $(wc -c < "$FULL_PATH") -gt $MAX_COMMENT_SIZE ]; then
          head -c "$MAX_COMMENT_SIZE" "$FULL_PATH" > "$TRUNC_PATH"
          echo -e "\n---\n:warning: Output truncated. See artifact for full details." >> "$TRUNC_PATH"
          echo "truncated_content=$(cat "$TRUNC_PATH")" >> "$GITHUB_OUTPUT"
        else
          cp "$FULL_PATH" "$TRUNC_PATH"
          echo "truncated_content=$(cat "$TRUNC_PATH")" >> "$GITHUB_OUTPUT"
        fi
      working-directory: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}

    - name: "üìù Post Terraform Plan Output to PR"
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      uses: peter-evans/create-or-update-comment@71345be0265236311c031f5c7866368bd1eff043
      with:
        token: ${{ inputs.github-token }}
        repository: ${{ github.repository }}
        issue-number: ${{ github.event.issue.number || github.event.pull_request.number }}
        comment-id: terraform-plan-${{ steps.branch-deploy.outputs.sha }}-${{ steps.branch-deploy.outputs.environment }}
        body: |
          ### üìã Terraform Plan Status: ${{ (steps.plan.outputs.plan_exit_code == 0 && '‚úÖ No Changes') || (steps.plan.outputs.plan_exit_code == 1 && '‚ùå Error') || (steps.plan.outputs.plan_exit_code == 2 && '‚ö†Ô∏è Changes Pending') || '‚ùì Unknown Status' }}

          ```terraform
          ${{ steps.truncate_plan.outputs.truncated_content }}
          ```
          ${{ steps.truncate_plan.outputs.artifact_needed == 'true' && format('Output truncated. See full log [here]({0}).', steps.get_plan_artifact_url.outputs.artifact_url) || '' }}
      env:
        PLAN_EXIT_CODE: ${{ steps.plan.outputs.plan_exit_code }}
        ARTIFACT_URL: ${{ steps.get_plan_artifact_url.outputs.artifact_url }}
        ARTIFACT_NEEDED: ${{ steps.truncate_plan.outputs.artifact_needed }}

    - name: "üì¶ Upload Plan Binary Artifact"
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      uses: actions/upload-artifact@v3
      with:
        name: terraform-plan-bin-${{ steps.branch-deploy.outputs.sha }}
        path: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/tfplan-${{ steps.branch-deploy.outputs.sha }}.binary
        compression-level: 0

    - name: "üè∑Ô∏è Tag Commit with Plan Run ID"
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      env:
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        set -euo pipefail
        TAG_NAME="terraform-branch-deploy/plan/${{ steps.branch-deploy.outputs.environment }}/${{ github.run_id }}/${{ steps.branch-deploy.outputs.sha }}"
        TAG_MESSAGE="terraform-branch-deploy plan artifact from run ${{ github.run_id }}. Triggered by @${{ github.actor }} on $(date -u)."

        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        if git rev-parse -q --verify "refs/tags/$TAG_NAME" >/dev/null; then
          echo "Overwriting existing plan tag for this commit and environment: $TAG_NAME"
          git tag -f "$TAG_NAME" "${{ steps.branch-deploy.outputs.sha }}" -m "$TAG_MESSAGE"
        else
          echo "Creating git tag: $TAG_NAME"
          git tag "$TAG_NAME" "${{ steps.branch-deploy.outputs.sha }}" -m "$TAG_MESSAGE"
        fi

        if ! git push origin "refs/tags/$TAG_NAME"; then
          echo "::warning::Failed to push git tag normally. Attempting force push. This might be due to a race condition or tag already existing remotely. Ensure the workflow has 'contents: write' permission."
          if ! git push -f origin "refs/tags/$TAG_NAME"; then
            echo "::error::Failed to push git tag, even with force. Ensure the workflow has 'contents: write' permission and no branch protection rules are preventing this operation."
            exit 1
          fi
        fi
        echo "‚úÖ Tagging complete."
      working-directory: repo_checkout

    # Terraform Apply:
    - name: "üîç Find Plan Run ID from Git Tag"
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      id: find_run_id
      run: |
        set -euo pipefail
        git fetch --tags

        COMMIT_SHA="${{ steps.branch-deploy.outputs.sha }}"
        TARGET_ENV="${{ steps.branch-deploy.outputs.environment }}"

        echo "Searching for plan tag for commit '$COMMIT_SHA' in environment '$TARGET_ENV'..."
        TAG=$(git for-each-ref "refs/tags/terraform-branch-deploy/plan/${TARGET_ENV}/*/${COMMIT_SHA}" \
          --sort=-creatordate --format='%(refname:short)' | head -n 1)

        if [ -z "$TAG" ]; then
          echo "::error::No terraform-branch-deploy plan tag found for commit '$COMMIT_SHA' in environment '$TARGET_ENV'."
          echo "Please ensure a plan was run and completed successfully for this commit and environment (e.g., '.plan to $TARGET_ENV') before attempting apply."
          exit 1
        fi

        echo "‚úÖ Found tag: $TAG"
        RUN_ID=$(echo "$TAG" | awk -F/ '{print $4}')

        if [ -z "$RUN_ID" ]; then
          echo "::error::Could not extract RUN_ID from tag '$TAG'. Tag format might be unexpected."
          exit 1
        FCI

        echo "Extracted RUN_ID: $RUN_ID"
        echo "run_id=${RUN_ID}" >> "$GITHUB_OUTPUT"
      shell: bash
      working-directory: repo_checkout

    - name: "‚¨áÔ∏è Download Plan Binary Artifact"
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      uses: dawidd6/action-download-artifact@ac66b43f0e6a346234dd65d4d0c8fbb31cb316e5
      with:
        github_token: ${{ inputs.github-token }}
        run_id: ${{ steps.find_run_id.outputs.run_id }}
        name: terraform-plan-bin-${{ steps.branch-deploy.outputs.sha }}
        path: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}

    - name: "üöÄ Terraform Apply"
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      id: apply
      run: |
        set -euo pipefail
        PLAN_BINARY_FILE="tfplan-${{ steps.branch-deploy.outputs.sha }}.binary"
        APPLY_OUTPUT_FILE="apply_output.txt"

        if [ ! -f "$PLAN_BINARY_FILE" ]; then
          echo "::error::Terraform plan binary '$PLAN_BINARY_FILE' not found. Ensure the plan step completed successfully and the artifact was uploaded/downloaded correctly."
          exit 1
        fi

        echo "Running terraform apply..."
        terraform apply ${{ steps.prepare_cmds.outputs.apply_args }} -no-color -auto-approve "$PLAN_BINARY_FILE" | tee "$APPLY_OUTPUT_FILE"
        APPLY_EXIT_CODE=$?

        MAX_COMMENT_SIZE=64000
        ARTIFACT_NEEDED=false
        FULL_APPLY_PATH="${GITHUB_WORKSPACE}/repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/${APPLY_OUTPUT_FILE}"

        if [ -f "$FULL_APPLY_PATH" ] && [ $(wc -c < "$FULL_APPLY_PATH") -gt $MAX_COMMENT_SIZE ]; then
          ARTIFACT_NEEDED=true
          echo "artifact_needed=true" >> "$GITHUB_OUTPUT"
        else
          echo "artifact_needed=false" >> "$GITHUB_OUTPUT"
        fi

        echo "apply_exit_code=$APPLY_EXIT_CODE" >> "$GITHUB_OUTPUT"

        if [ "$APPLY_EXIT_CODE" -eq 0 ]; then
          echo "‚úÖ Terraform apply completed successfully."
        elif [ "$APPLY_EXIT_CODE" -eq 1 ]; then
          echo "::error::Terraform apply failed with a critical error."
        else
          echo "::warning::Terraform apply completed with non-zero exit code: $APPLY_EXIT_CODE."
        fi
        exit "$APPLY_EXIT_CODE"
      shell: bash
      working-directory: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}

    - name: "üì§ Upload Apply Output Artifact"
      if: steps.apply.outputs.artifact_needed == 'true'
      id: upload_apply_artifact
      uses: actions/upload-artifact@v3
      with:
        name: terraform-apply-output-${{ steps.branch-deploy.outputs.sha }}
        path: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/apply_output.txt
        compression-level: 0

    - name: "üîó Get Apply Artifact URL"
      if: steps.apply.outputs.artifact_needed == 'true'
      id: get_apply_artifact_url
      uses: actions/github-script@v7
      with:
        script: |
          const runId = context.runId;
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const sha = "${{ steps.branch-deploy.outputs.sha }}";
          const artifactName = `terraform-apply-output-${sha}`;

          try {
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: owner,
              repo: repo,
              run_id: runId
            });

            const artifact = artifacts.data.artifacts.find(a => a.name === artifactName);
            if (artifact) {
              core.setOutput('artifact_url', artifact.archive_download_url);
              core.debug(`Found artifact URL: ${artifact.archive_download_url}`);
            } else {
              core.setOutput('artifact_url', '');
              core.warning(`Artifact '${artifactName}' not found for run ${runId}. This might indicate a problem with artifact upload.`);
            }
          } catch (error) {
            core.setFailed(`Failed to get artifact URL: ${error.message}`);
          }
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}

    - name: "‚úÇÔ∏è Truncate Apply Output for PR Comment"
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      id: truncate_apply
      shell: bash
      run: |
        set -euo pipefail
        MAX_COMMENT_SIZE=64000
        INPUT_FILE="apply_output.txt"
        OUTPUT_FILE="apply_output.trunc.txt"

        FULL_PATH="${GITHUB_WORKSPACE}/repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/${INPUT_FILE}"
        TRUNC_PATH="${GITHUB_WORKSPACE}/repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}/${OUTPUT_FILE}"

        ARTIFACT_NEEDED=${{ steps.apply.outputs.artifact_needed }}

        if [ -f "$FULL_PATH" ] && [ $(wc -c < "$FULL_PATH") -gt $MAX_COMMENT_SIZE ]; then
          head -c "$MAX_COMMENT_SIZE" "$FULL_PATH" > "$TRUNC_PATH"
          echo -e "\n---\n:warning: Output truncated. See artifact for full details." >> "$TRUNC_PATH"
          echo "truncated_content=$(cat "$TRUNC_PATH")" >> "$GITHUB_OUTPUT"
        else
          cp "$FULL_PATH" "$TRUNC_PATH"
          echo "truncated_content=$(cat "$TRUNC_PATH")" >> "$GITHUB_OUTPUT"
        fi
      working-directory: repo_checkout/${{ steps.prepare_cmds.outputs.working_dir }}

    - name: "üìù Post Terraform Apply Output to PR"
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      uses: peter-evans/create-or-update-comment@71345be0265236311c031f5c7866368bd1eff043
      with:
        token: ${{ inputs.github-token }}
        repository: ${{ github.repository }}
        issue-number: ${{ github.event.issue.number || github.event.pull_request.number }}
        comment-id: terraform-apply-${{ steps.branch-deploy.outputs.sha }}-${{ steps.branch-deploy.outputs.environment }}
        body: |
          ### üöÄ Terraform Apply Status: ${{ (steps.apply.outputs.apply_exit_code == 0 && '‚úÖ Succeeded') || (steps.apply.outputs.apply_exit_code == 1 && '‚ùå Failed') || '‚ö†Ô∏è Completed with Changes' }}

          ```terraform
          ${{ steps.truncate_apply.outputs.truncated_content }}
          ```
          ${{ steps.truncate_apply.outputs.artifact_needed == 'true' && format('Output truncated. See full log [here]({0}).', steps.get_apply_artifact_url.outputs.artifact_url) || '' }}
      env:
        APPLY_EXIT_CODE: ${{ steps.apply.outputs.apply_exit_code }}
        ARTIFACT_URL: ${{ steps.get_apply_artifact_url.outputs.artifact_url }}
        ARTIFACT_NEEDED: ${{ steps.truncate_apply.outputs.artifact_needed }}
